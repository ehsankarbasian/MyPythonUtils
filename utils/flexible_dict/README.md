در خواندن داده‌ها از دیکشنری های تو در تویی که وجود key هایی که می‌خوانیم قطعی نیست ناچار به هندل کردن خطا ها هستیم. در هندل کردن خطا ها ممکن است بخواهیم یک مقدار پیش‌فرض به مقادیری که کلید های آن‌ها وجود نداشته است بدهیم در حالی که در حال خواندن چندین دیکشنری تو در تو هستیم.
دیکشنری ای که تحت عنوان FlexibleDict از روی دیکشنری پایتون بازتعریف شده است نیازی به این هندل کردن خطا ها ندارد و با خواندن پی در پی کلید هایی که وجود دارند یا ندارند منجر به خطا نمی شود. در صورتی که در کلید هاییی که می‌خوانیم کلیدی وجود داشته باشد که در دیکشنری نباشد به ما مقدار پیشفرضی که از قبل تنظیم کرده‌ایم برگردانده می شود.

نکته ی مهم آن است که این مقدار پیش‌فرض هم قابلیت خواندن کلید ها روی خود را دارد پس اگر در وسط خواندن کلید های پی در پی به مقدار پیش‌فرض برخورد کردیم در خواندن کلید های بعدی به خطا نمی‌خوریم و پس از تمام شدن زنجیره ی کلید هایی که می‌خواهیم بخوانیم به ما مقدار پیش‌فرض برگردانده می شود.
نمونه ی استفاده از این کلاس در فایل how_to_use.py در همین پکیج موجود است.
در ادامه توضیحات بیشتری در مورد نحوه ی ساخت این آبجکت و توابع قابل استفاده در این نوع داده خواهیم داد:


<h2>نحوه ی ساخت:</h2>
my_flexible_dict = FlexibleDict(input_dict=a_simple_dict, default, iterable_default)
یک دیکشنری معمولی بعنوان input_dict به کلاس می‌دهیم تا آن را در دیکشنری جدید load کند.
مقدار default را برابر مقداری قرار می‌دهیم که می‌خواهیم در صورت وجود نداشتن key ای که می‌خوانیم به ما برگردانده شود.
در مورد iterable_default در بخش بعدی توضیح داده خواهد شد.


<h2>توابع قابل استفاده(نحوه ی خواندن داده):</h2>
برای خواندن key های پی در پی ابتدا یکی پس از دیگری کلید ها را می‌خوانیم.
برای گرفتن مقداری که در آن کلید ذخیره شده است سه کار می‌توانیم انجام دهیم:<br>
<h3>1. ( value. )</h3>

 برای گرفتن مقدار بدون هیچ شرطی از value. استفاده می کنیم. در این حالت اگر مقداری با آن کلید ها وجود داشته باشد برگردانده می‌شود و در غیر این صورت مقداری برگردانده می‌شود که هنگام ساخت آبجکت به متغیر default دادیم.
لازم به ذکر است که مقداری که بر می‌گردد از type های استاندارد پایتون می‌باشد و حتی اگر دیکشنری باشد از نوع dict است و از نوع FlexibleDict نیست.
حالت اول پر کاربرد ترین حالت است که برای خواندن های معمولی به کار می رود. حالت‌های دیگر ممکن است برای نیاز های دیگری مفید تر باشند که توضیح خواهیم داد.<br>
<h3>2. ( flexible_value. )</h3>
 اگر بخواهیم مقداری که به ما برگردانده می‌شود همانند FlexibleDict قابل خواندن کلید های پی در پی باشد می‌توان از flexible_value. استفاده کرد.
مقداری که بر می‌گردد چه دیکشنری باشد و چه نوع دیگری باشد قابلیت خواندن کلید ها را مثل FlexibleDict دارد.
لازم به ذکر است که برای گرفتن مقدار نهایی استاندارد باید همچنان از value. استفاده کنیم.<br>
<h3>3. ( iterable_value. )</h3>
 اگر بخواهیم روی مقداری که پس از خواندن کلید ها می‌گیریم حلقه ی for اجرا کنیم باید مطمئن شویم که آن مقدار iterable است تا به خطا بر نخوریم.
اگر از iterable_value. استفاده کنیم این اطمینان حاصل می شود. به این صورت که اگر آن مقدار iterable بود همان مقدار به ما برگردانده می‌شود و در غیر این صورت مقدار iterable_default که در هنگام ساختن آبجکت از FlexibleDict به آن می‌دهیم به ما برگردانده خواهد شد. به این صورت بدون نیاز به چک کردن iterable بودن مقادیر می‌توان برای هندل کردن خطا های پیمایش به مقدار iterable_default یک لیست خالی داد که با برگردانده شدن لیست خالی دیگر حلقه ی for اجرا نخواهد شد.